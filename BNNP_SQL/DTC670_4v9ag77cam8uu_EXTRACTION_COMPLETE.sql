-- ============================================================
-- DTC670 - EXTRACTION COMPLETE (Equivalent Package BAATGS)
-- ============================================================
-- SQL_ID : 4v9ag77cam8uu
-- Date : 20/02/2026
-- ============================================================
-- Ce script reproduit EXACTEMENT le comportement de :
--   F_Extraire_BAATGS + F_Generation_BAATGS
-- avec l'optimisation CTE pour DC_MAX
-- ============================================================
-- USAGE :
--   1. Modifier P_DATE_ARRETE et P_TYPE_RAPRO
--   2. Executer dans SQL*Plus
--   3. Le fichier CSV sera genere dans /tmp/
-- ============================================================

SET SERVEROUTPUT ON SIZE UNLIMITED
SET LINESIZE 2000
SET PAGESIZE 0
SET TRIMSPOOL ON
SET FEEDBACK OFF
SET HEADING OFF
SET TIMING ON

-- ============================================================
-- SCHEMA : Utiliser le schema EXP_RNAPA pour les synonymes
-- ============================================================
ALTER SESSION SET CURRENT_SCHEMA = EXP_RNAPA;

-- Parametres (MODIFIER selon vos besoins)
DEFINE P_DATE_ARRETE = '28/02/2026'
DEFINE P_TYPE_RAPRO = 'RB'

PROMPT ============================================================
PROMPT DTC670 - EXTRACTION COMPLETE BAATGS
PROMPT Date arrete : &P_DATE_ARRETE
PROMPT Type rapro  : &P_TYPE_RAPRO
PROMPT ============================================================

-- ============================================================
-- ETAPE 1/4 : TRUNCATE TABLE BA_ATTENDUS_GEST
-- ============================================================
PROMPT [1/4] Truncate BA_ATTENDUS_GEST...
TRUNCATE TABLE BA_ATTENDUS_GEST;

-- ============================================================
-- ETAPE 2/4 : INSERT avec CTE OPTIMISE + Calcul MONTANT_PROVISION
-- ============================================================
PROMPT [2/4] Insertion donnees optimisees (CTE)...

INSERT INTO BA_ATTENDUS_GEST (
    DATE_ARRETE, TYPE_RAPRO, SERVICE, SOCIETE, COMPTE_BANCAIRE, LIBELLE_COMPTE,
    DEVISE, DATE_OPERATION_SUSPENS, LIBELLE_SUSPENS, DEBIT, CREDIT, SENS_ATTENDU, COTE_SUSPENS,
    ANCIENNETE_J, ANCIENNETE_M, BORNE_ANCIENNETE, PILIER_MONTANT_DEBIT, PILIER_MONTANT_CREDIT,
    METHODE_PROVISION, TAUX, MONTANT_PROVISION, STATUT, DATE_APUREMENT, DC_MAX, PRIORITE, COMMENTAIRE,
    NETTING, DELTA, SENS_DELTA, NUMERO_FICHE, DERNIER_STATUT, RECORD_ID, ANNOTE_LE
)
WITH
-- CTE 1 : Pre-calcul DC_MAX (UNE SEULE FOIS)
dc_max_calc AS (
    SELECT /*+ MATERIALIZE */
        RECONCILIATION_REFERENCE,
        ACCOUNT_ID,
        MAX(TRANSACTION_DATE) AS DC_MAX
    FROM BRR_TRANSACTIONS
    WHERE RECONCILIATION_REFERENCE IS NOT NULL
    GROUP BY RECONCILIATION_REFERENCE, ACCOUNT_ID
),
-- CTE 2 : Hierarchie des comptes
compte_hierarchie AS (
    SELECT /*+ MATERIALIZE */
        H.ACCOUNT_ID,
        B2.ACCT_NUM AS SERVICE,
        RPAD(B3.ACCT_NUM, LENGTH(B3.ACCT_NUM)-2) AS TYPE_RAPRO_CODE,
        DECODE(RPAD(B3.ACCT_NUM, LENGTH(B3.ACCT_NUM)-2),
            'RB', 'Rapprochement Bancaire',
            'RC', 'Rapprochement de Controle',
            'JC', 'Justification de compte',
            'CL', 'Compte de liaison') AS TYPE_RAPRO
    FROM BRR_ACCOUNT_HIERARCHIES H
    JOIN BS_ACCTS B2 ON B2.ACCT_ID = H.LEVEL_02_ACCOUNT_ID
    JOIN BS_ACCTS B3 ON B3.ACCT_ID = H.LEVEL_03_ACCOUNT_ID
),
-- CTE 3 : Donnees brutes OUTSTANDING
raw_outstanding AS (
    SELECT /*+ LEADING(T A CH CM) USE_HASH(A CH CM) */
        TO_CHAR(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR')) AS DATE_ARRETE,
        CH.TYPE_RAPRO,
        CH.SERVICE,
        (SELECT ACCT_NAME FROM BS_ACCTS WHERE ACCT_ID = A.ACCT_GROUP) AS SOCIETE,
        CM.COMPTE_BANCAIRE,
        A.ACCT_NAME AS LIBELLE_COMPTE,
        A.ACCT_CURRENCY AS DEVISE,
        TO_CHAR(T.TRANSACTION_DATE, 'DD/MM/RRRR') AS DATE_OPERATION_SUSPENS,
        T.NARRATIVE AS LIBELLE_SUSPENS,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTSTATEMENT', T.AMOUNT, 'RECEIPTCASHBOOK', T.AMOUNT) AS DEBIT,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'RECEIPTSTATEMENT', T.AMOUNT, 'PAYMENTCASHBOOK', T.AMOUNT) AS CREDIT,
        DECODE(T.NUMERIC_TWO, 0,
            DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTCASHBOOK', 'ABD', 'PAYMENTSTATEMENT', 'ACC', 'RECEIPTCASHBOOK', 'ABC', 'RECEIPTSTATEMENT', 'ACD'),
            'A'||T.FLAG_C||DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTCASHBOOK', 'D', 'PAYMENTSTATEMENT', 'C', 'RECEIPTCASHBOOK', 'C', 'RECEIPTSTATEMENT', 'D')
        ) AS SENS_ATTENDU,
        DECODE(T.SIDE, 'STATEMENT', 'B', 'CASHBOOK', 'C') AS COTE_SUSPENS,
        TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR') - T.TRANSACTION_DATE AS ANCIENNETE_J,
        MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) AS ANCIENNETE_M,
        (SELECT LIBELLE_ANCIENNETE FROM BA_CATEG_ANCIENNETE
         WHERE MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) >= BORNE_INF
           AND MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) < BORNE_SUP) AS BORNE_ANCIENNETE,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE,
            'PAYMENTSTATEMENT', (SELECT LIBELLE_PILIER FROM BA_PILIERS_MONTANTS WHERE T.AMOUNT >= BORNE_INF AND T.AMOUNT < BORNE_SUP),
            'RECEIPTCASHBOOK', (SELECT LIBELLE_PILIER FROM BA_PILIERS_MONTANTS WHERE T.AMOUNT >= BORNE_INF AND T.AMOUNT < BORNE_SUP)
        ) AS PILIER_MONTANT_DEBIT,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE,
            'RECEIPTSTATEMENT', (SELECT LIBELLE_PILIER FROM BA_PILIERS_MONTANTS WHERE T.AMOUNT >= BORNE_INF AND T.AMOUNT < BORNE_SUP),
            'PAYMENTCASHBOOK', (SELECT LIBELLE_PILIER FROM BA_PILIERS_MONTANTS WHERE T.AMOUNT >= BORNE_INF AND T.AMOUNT < BORNE_SUP)
        ) AS PILIER_MONTANT_CREDIT,
        CM.METHODE AS METHODE_PROVISION,
        (SELECT TAUX FROM BA_METHODE_PROVISION
         WHERE METHODE = CM.METHODE
           AND MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) >= BORNE_INF
           AND MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) < BORNE_SUP) AS TAUX,
        T.STATE AS STATUT,
        NULL AS DATE_APUREMENT,
        NULL AS DC_MAX,
        SUBSTR(T.CHARACTER_SIXTEEN, 1, 5) AS PRIORITE,
        T.LAST_NOTE_TEXT AS COMMENTAIRE,
        T.NUMERIC_TWO AS NETTING,
        DECODE(DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTSTATEMENT', T.AMOUNT, 'RECEIPTCASHBOOK', T.AMOUNT),
            NULL, DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'RECEIPTSTATEMENT', T.AMOUNT, 'PAYMENTCASHBOOK', T.AMOUNT),
            DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTSTATEMENT', T.AMOUNT, 'RECEIPTCASHBOOK', T.AMOUNT)
        ) AS DELTA,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTCASHBOOK', 'D', 'PAYMENTSTATEMENT', 'C', 'RECEIPTCASHBOOK', 'C', 'RECEIPTSTATEMENT', 'D') AS SENS_DELTA,
        '' AS NUMERO_FICHE,
        '' AS DERNIER_STATUT,
        T.RECORD_ID,
        CASE T.DATE_LAST_NOTE_ADDED
            WHEN TO_DATE('01/01/1980', 'DD/MM/RRRR') THEN NULL
            ELSE TO_CHAR(T.DATE_LAST_NOTE_ADDED, 'DD/MM/RRRR')
        END AS ANNOTE_LE
    FROM BRR_TRANSACTIONS T
    JOIN BS_ACCTS A ON A.ACCT_ID = T.ACCOUNT_ID
    JOIN BA_COMPTE_METHODE CM ON CM.ACCOUNT_ID = A.ACCT_ID
    JOIN compte_hierarchie CH ON CH.ACCOUNT_ID = A.ACCT_ID
    WHERE CH.TYPE_RAPRO_CODE = '&P_TYPE_RAPRO'
      AND CH.SERVICE = 'GESTION'
      AND T.TRANSACTION_DATE <= TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR')
      AND T.STATE = 'OUTSTANDING'
),
-- CTE 4 : Donnees brutes RECONCILED
raw_reconciled AS (
    SELECT /*+ LEADING(T A CH CM DCM) USE_HASH(A CH CM DCM) */
        TO_CHAR(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR')) AS DATE_ARRETE,
        CH.TYPE_RAPRO,
        CH.SERVICE,
        (SELECT ACCT_NAME FROM BS_ACCTS WHERE ACCT_ID = A.ACCT_GROUP) AS SOCIETE,
        CM.COMPTE_BANCAIRE,
        A.ACCT_NAME AS LIBELLE_COMPTE,
        A.ACCT_CURRENCY AS DEVISE,
        TO_CHAR(T.TRANSACTION_DATE, 'DD/MM/RRRR') AS DATE_OPERATION_SUSPENS,
        T.NARRATIVE AS LIBELLE_SUSPENS,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTSTATEMENT', T.AMOUNT, 'RECEIPTCASHBOOK', T.AMOUNT) AS DEBIT,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'RECEIPTSTATEMENT', T.AMOUNT, 'PAYMENTCASHBOOK', T.AMOUNT) AS CREDIT,
        DECODE(T.NUMERIC_TWO, 0,
            DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTCASHBOOK', 'ABD', 'PAYMENTSTATEMENT', 'ACC', 'RECEIPTCASHBOOK', 'ABC', 'RECEIPTSTATEMENT', 'ACD'),
            'A'||T.FLAG_C||DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTCASHBOOK', 'D', 'PAYMENTSTATEMENT', 'C', 'RECEIPTCASHBOOK', 'C', 'RECEIPTSTATEMENT', 'D')
        ) AS SENS_ATTENDU,
        DECODE(T.SIDE, 'STATEMENT', 'B', 'CASHBOOK', 'C') AS COTE_SUSPENS,
        TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR') - T.TRANSACTION_DATE AS ANCIENNETE_J,
        MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) AS ANCIENNETE_M,
        (SELECT LIBELLE_ANCIENNETE FROM BA_CATEG_ANCIENNETE
         WHERE MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) >= BORNE_INF
           AND MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) < BORNE_SUP) AS BORNE_ANCIENNETE,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE,
            'PAYMENTSTATEMENT', (SELECT LIBELLE_PILIER FROM BA_PILIERS_MONTANTS WHERE T.AMOUNT >= BORNE_INF AND T.AMOUNT < BORNE_SUP),
            'RECEIPTCASHBOOK', (SELECT LIBELLE_PILIER FROM BA_PILIERS_MONTANTS WHERE T.AMOUNT >= BORNE_INF AND T.AMOUNT < BORNE_SUP)
        ) AS PILIER_MONTANT_DEBIT,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE,
            'RECEIPTSTATEMENT', (SELECT LIBELLE_PILIER FROM BA_PILIERS_MONTANTS WHERE T.AMOUNT >= BORNE_INF AND T.AMOUNT < BORNE_SUP),
            'PAYMENTCASHBOOK', (SELECT LIBELLE_PILIER FROM BA_PILIERS_MONTANTS WHERE T.AMOUNT >= BORNE_INF AND T.AMOUNT < BORNE_SUP)
        ) AS PILIER_MONTANT_CREDIT,
        CM.METHODE AS METHODE_PROVISION,
        (SELECT TAUX FROM BA_METHODE_PROVISION
         WHERE METHODE = CM.METHODE
           AND MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) >= BORNE_INF
           AND MONTHS_BETWEEN(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), T.TRANSACTION_DATE) < BORNE_SUP) AS TAUX,
        T.STATE AS STATUT,
        TO_DATE(T.UPDATE_TIME, 'DD/MM/RRRR') AS DATE_APUREMENT,
        DCM.DC_MAX AS DC_MAX,
        SUBSTR(T.CHARACTER_SIXTEEN, 1, 5) AS PRIORITE,
        T.LAST_NOTE_TEXT AS COMMENTAIRE,
        T.NUMERIC_TWO AS NETTING,
        DECODE(DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTSTATEMENT', T.AMOUNT, 'RECEIPTCASHBOOK', T.AMOUNT),
            NULL, DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'RECEIPTSTATEMENT', T.AMOUNT, 'PAYMENTCASHBOOK', T.AMOUNT),
            DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTSTATEMENT', T.AMOUNT, 'RECEIPTCASHBOOK', T.AMOUNT)
        ) AS DELTA,
        DECODE(T.PAYMENT_OR_RECEIPT||T.SIDE, 'PAYMENTCASHBOOK', 'D', 'PAYMENTSTATEMENT', 'C', 'RECEIPTCASHBOOK', 'C', 'RECEIPTSTATEMENT', 'D') AS SENS_DELTA,
        '' AS NUMERO_FICHE,
        '' AS DERNIER_STATUT,
        T.RECORD_ID,
        CASE T.DATE_LAST_NOTE_ADDED
            WHEN TO_DATE('01/01/1980', 'DD/MM/RRRR') THEN NULL
            ELSE TO_CHAR(T.DATE_LAST_NOTE_ADDED, 'DD/MM/RRRR')
        END AS ANNOTE_LE
    FROM BRR_TRANSACTIONS T
    JOIN BS_ACCTS A ON A.ACCT_ID = T.ACCOUNT_ID
    JOIN BA_COMPTE_METHODE CM ON CM.ACCOUNT_ID = A.ACCT_ID
    JOIN compte_hierarchie CH ON CH.ACCOUNT_ID = A.ACCT_ID
    JOIN dc_max_calc DCM ON DCM.RECONCILIATION_REFERENCE = T.RECONCILIATION_REFERENCE
                         AND DCM.ACCOUNT_ID = T.ACCOUNT_ID
    WHERE CH.TYPE_RAPRO_CODE = '&P_TYPE_RAPRO'
      AND CH.SERVICE = 'GESTION'
      AND T.TRANSACTION_DATE <= TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR')
      AND T.STATE = 'RECONCILED'
      AND DCM.DC_MAX >= TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR')
),
-- CTE 5 : Union des deux
raw_data AS (
    SELECT * FROM raw_outstanding
    UNION ALL
    SELECT * FROM raw_reconciled
)
-- SELECT final avec calcul MONTANT_PROVISION
SELECT DISTINCT
    DATE_ARRETE,
    TYPE_RAPRO,
    SERVICE,
    SOCIETE,
    COMPTE_BANCAIRE,
    LIBELLE_COMPTE,
    DEVISE,
    DATE_OPERATION_SUSPENS,
    LIBELLE_SUSPENS,
    DEBIT,
    CREDIT,
    SENS_ATTENDU,
    COTE_SUSPENS,
    ANCIENNETE_J,
    ANCIENNETE_M,
    BORNE_ANCIENNETE,
    PILIER_MONTANT_DEBIT,
    PILIER_MONTANT_CREDIT,
    METHODE_PROVISION,
    -- TAUX : 0 si SENS_DELTA = 'D' et NETTING = 0
    CASE WHEN SENS_DELTA = 'D' AND NETTING = 0 THEN 0 ELSE TAUX END AS TAUX,
    -- MONTANT_PROVISION : TAUX * (DEBIT ou CREDIT), 0 si SENS_DELTA='D' et NETTING=0
    CASE
        WHEN SENS_DELTA = 'D' AND NETTING = 0 THEN 0
        WHEN DEBIT IS NOT NULL THEN NVL(TAUX, 0) * DEBIT
        ELSE NVL(TAUX, 0) * CREDIT
    END AS MONTANT_PROVISION,
    STATUT,
    DATE_APUREMENT,
    DC_MAX,
    PRIORITE,
    COMMENTAIRE,
    NETTING,
    DELTA,
    SENS_DELTA,
    NUMERO_FICHE,
    DERNIER_STATUT,
    RECORD_ID,
    ANNOTE_LE
FROM raw_data;

COMMIT;

PROMPT [2/4] Insertion terminee.
SELECT COUNT(*) || ' lignes inserees dans BA_ATTENDUS_GEST' FROM BA_ATTENDUS_GEST;

-- ============================================================
-- ETAPE 3/4 : Recalcul NETTING (lignes preletrees)
-- ============================================================
PROMPT [3/4] Recalcul des lignes preletrees (NETTING)...

-- Pour chaque groupe de NETTING, recalculer le DELTA sur la ligne la plus ancienne
-- et mettre les autres DELTA a 0
DECLARE
    v_min_record_id NUMBER;
    v_sum_delta NUMBER;
BEGIN
    FOR rec IN (
        SELECT DISTINCT DATE_ARRETE, TYPE_RAPRO, SERVICE, SOCIETE,
               COMPTE_BANCAIRE, LIBELLE_COMPTE, DEVISE, NETTING
        FROM BA_ATTENDUS_GEST
        WHERE NETTING != 0
        ORDER BY SOCIETE, COMPTE_BANCAIRE, DEVISE
    ) LOOP
        -- Trouver le RECORD_ID le plus ancien (le plus petit) du groupe
        SELECT MIN(RECORD_ID) INTO v_min_record_id
        FROM BA_ATTENDUS_GEST
        WHERE DATE_ARRETE = rec.DATE_ARRETE
          AND SOCIETE = rec.SOCIETE
          AND COMPTE_BANCAIRE = rec.COMPTE_BANCAIRE
          AND DEVISE = rec.DEVISE
          AND NETTING = rec.NETTING;

        -- Calculer la somme des DELTA du groupe
        SELECT SUM(DELTA) INTO v_sum_delta
        FROM BA_ATTENDUS_GEST
        WHERE DATE_ARRETE = rec.DATE_ARRETE
          AND SOCIETE = rec.SOCIETE
          AND COMPTE_BANCAIRE = rec.COMPTE_BANCAIRE
          AND DEVISE = rec.DEVISE
          AND NETTING = rec.NETTING;

        -- Mettre DELTA = somme sur la ligne la plus ancienne
        UPDATE BA_ATTENDUS_GEST
        SET DELTA = v_sum_delta,
            TAUX = 0,
            MONTANT_PROVISION = 0
        WHERE RECORD_ID = v_min_record_id;

        -- Mettre DELTA = 0 sur les autres lignes du groupe
        UPDATE BA_ATTENDUS_GEST
        SET DELTA = 0,
            TAUX = 0,
            MONTANT_PROVISION = 0
        WHERE DATE_ARRETE = rec.DATE_ARRETE
          AND SOCIETE = rec.SOCIETE
          AND COMPTE_BANCAIRE = rec.COMPTE_BANCAIRE
          AND DEVISE = rec.DEVISE
          AND NETTING = rec.NETTING
          AND RECORD_ID != v_min_record_id;
    END LOOP;
    COMMIT;
END;
/

PROMPT [3/4] Recalcul NETTING termine.

-- ============================================================
-- ETAPE 4/4 : EXPORT CSV (format identique au package)
-- ============================================================
PROMPT [4/4] Generation du fichier CSV...

-- Nom du fichier de sortie
COLUMN filename NEW_VALUE output_file
SELECT 'ACCURATE_A' || TO_CHAR(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), 'YYYY') ||
       '_M' || TO_CHAR(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), 'MM') ||
       '_J' || TO_CHAR(TO_DATE('&P_DATE_ARRETE', 'DD/MM/RRRR'), 'DD') ||
       '_' || TO_CHAR(SYSDATE, 'DD-MM-YYYY') ||
       '_&P_TYPE_RAPRO._BAATGS.txt' AS filename
FROM DUAL;

SPOOL /tmp/&output_file

-- En-tete CSV
SELECT 'DATE_ARRETE,TYPE_RAPRO,SERVICE,SOCIETE,COMPTE_BANCAIRE,LIBELLE_COMPTE,' ||
       'DEVISE,DATE_OPERATION_SUSPENS,LIBELLE_SUSPENS,DEBIT,CREDIT,CUMUL_DEBIT_CREDIT,SENS_ATTENDU,' ||
       'COTE_SUSPENS,ANCIENNETE_J,BORNE_ANCIENNETE,PILIER_MONTANT_DEBIT,PILIER_MONTANT_CREDIT,PILIER_MONTANT_CUMUL_DEBIT_CREDIT,' ||
       'METHODE_PROVISION,NETTING,DELTA,SENS_DELTA,ID_ECRITURE,TAUX,' ||
       'MONTANT_PROVISION,DATE_APUREMENT,POST_ARRETE_DC_MAX,PRIORITE,COMMENTAIRE,NUMERO_FICHE,DERNIER_STATUT,RECORD_ID,ANNOTE_LE'
FROM DUAL;

-- Donnees CSV
SELECT
    DATE_ARRETE || ',' ||
    TYPE_RAPRO || ',' ||
    SERVICE || ',' ||
    REPLACE(SOCIETE, ',', ' ') || ',' ||
    COMPTE_BANCAIRE || ',' ||
    REPLACE(LIBELLE_COMPTE, ',', ' ') || ',' ||
    DEVISE || ',' ||
    DATE_OPERATION_SUSPENS || ',' ||
    REPLACE(REPLACE(REPLACE(LIBELLE_SUSPENS, ',', ' '), CHR(10), '-'), CHR(13), '') || ',' ||
    NVL(TO_CHAR(DEBIT), '') || ',' ||
    NVL(TO_CHAR(CREDIT), '') || ',' ||
    NVL(TO_CHAR(NVL(DEBIT, CREDIT)), '') || ',' ||
    SENS_ATTENDU || ',' ||
    COTE_SUSPENS || ',' ||
    ANCIENNETE_J || ',' ||
    BORNE_ANCIENNETE || ',' ||
    PILIER_MONTANT_DEBIT || ',' ||
    PILIER_MONTANT_CREDIT || ',' ||
    NVL(PILIER_MONTANT_DEBIT, PILIER_MONTANT_CREDIT) || ',' ||
    METHODE_PROVISION || ',' ||
    NETTING || ',' ||
    CASE WHEN DELTA != 0 THEN REPLACE(TO_CHAR(DELTA), '.', ',') ELSE '-' END || ',' ||
    SENS_DELTA || ',' ||
    RECORD_ID || ',' ||
    CASE WHEN TAUX != 0 THEN TO_CHAR(TAUX*100) || '%' ELSE '-' END || ',' ||
    CASE WHEN MONTANT_PROVISION != 0 THEN REPLACE(TO_CHAR(MONTANT_PROVISION), '.', ',') ELSE '-' END || ',' ||
    NVL(TO_CHAR(DATE_APUREMENT), '') || ',' ||
    NVL(TO_CHAR(DC_MAX, 'DD/MM/RRRR'), '') || ',' ||
    PRIORITE || ',' ||
    REPLACE(REPLACE(REPLACE(COMMENTAIRE, ',', ' '), CHR(10), '-'), CHR(13), '') || ',' ||
    NUMERO_FICHE || ',' ||
    DERNIER_STATUT || ',' ||
    RECORD_ID || ',' ||
    ANNOTE_LE
FROM BA_ATTENDUS_GEST
ORDER BY SERVICE, SOCIETE, COMPTE_BANCAIRE, TO_DATE(DATE_OPERATION_SUSPENS, 'DD/MM/RRRR'), NETTING;

SPOOL OFF

PROMPT
PROMPT ============================================================
PROMPT EXTRACTION TERMINEE
PROMPT Fichier genere : /tmp/&output_file
PROMPT ============================================================

SET TIMING OFF
SET FEEDBACK ON
SET HEADING ON

/*
============================================================
VERIFICATION
============================================================
Pour verifier que l'extraction est identique au package :

1. Compter les lignes :
   SELECT COUNT(*) FROM BA_ATTENDUS_GEST;

2. Verifier un echantillon :
   SELECT * FROM BA_ATTENDUS_GEST WHERE ROWNUM <= 10;

3. Comparer avec le fichier du package si disponible
============================================================
*/
